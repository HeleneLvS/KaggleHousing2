---
title: "R Notebook for the Housepricing Comp"
output: html_notebook
---

```{r admin, include = FALSE}
##clean out the space
rm(list=ls())
options(scipen=999)

##What do we need
library(tidyr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(cowplot) # plot different ggplots next to each other
#install.packages("DataExplorer")
library(DataExplorer)
library(corrplot)
library(pscl) # For Pseudo R squareds on GLMS

#Where will we work
getwd()
setwd("C:/Users/helen/Documents/Kaggle/HousePrice")

```

The Data explorer package is great for a first stab at unknown data. First things first;

-   The dependent variable - the thing we want to predict - is continuous --\> regression problem
    -   GLM: Gamma with Log, Inverse or Identity link
    -   Regression Tree
    -   Random Forrest Reg Tree
-   Not normally distributed --\> important to match the algo to the distribution transformation
    -   Gool ol' OLS with a transformation?
-   Loads of missing data to remedy
    -   Which means we should add the test and train sets together - to save effort when scoring & validating

```{r EDA}

train<-read.csv("train.csv")

train['Type']<-'train_set'

test<-read.csv("test.csv")
test['SalePrice'] <- NA
test['Type']<-'test_set'

data<-rbind(train,test)

#create_report(train)
#create_report(data)
plot_intro(data)
plot_missing(data)
```

Start by filling in the missing data and running some correlation plots to understand the multicollinearity;

-   By completing the NA values we drop from 5.8% missing observations to 0.33%

-   The remaining two significantly missing values are for

    -   LotFrontage and

    -   Garage built

-   The latter's missing value shows there is no Garage on the premises while the LotFrontage might just show that the property is not on a municipal street. However this may be an incorrect assumption so an alternative is to build a model on LotFrontage as a factor of LotConfig and LotArea. On closer inspection imputing missings with 0's ruins a pretty nice linear correlation between SalePrice and LotFrontage so lets start with the model. Garage built will be imputed with 3000 to represent the future.

    ```{r CleanupandFill}
    #Fill in the NA's where they represent 'None Present' with 'Non' 

    data_f<-data %>%
      replace_na(list(Alley = "Non", BsmtQual = "Non", BsmtExposure = "Non",
                      BsmtCond= "Non", BsmtFinType1="Non", BsmtFinType2="Non",
                      FireplaceQu = "Non", GarageType = "Non",GarageFinish = "Non",
                      GarageQual="Non", GarageCond="Non", 
                      PoolQC="Non", Fence = "None", GarageQual="Non", 
                      GarageCond = "Non", PoolQC = "Non", MiscFeature = "Non"))


    data_f<-data_f %>% 
      replace_na(list(GarageYrBlt = 3000))
    ## Add this bit for another set: LotFrontage = 0, if the above gives a poor result
    ## Predict the LotFrontage based on total sqft and Configuration of the lot with m3
    data_ltz<-subset(data_f, LotFrontage > 0)  
    m3 <- glm(LotFrontage~LotArea+LotConfig, Gamma(link="log"), data = data_ltz)       
    data_f$LotFrontageHat<- predict(m3,data_f,type="response")        
    data_f$LotFrontageHat<-case_when(data_f$LotFrontageHat >= 200 ~ 225,
                                  TRUE ~data_f$LotFrontageHat)

    data_f$LotFrontage<-data_f$LotFrontageHat
    ####*******************START************************############
    ##ADD THIS TO A NEW NOTEBOOK TO LOAD FOR IMPUTATION
    #imputedLFH<-data_f[,c(4,83,81)]
    #im1<-subset(imputedLFH, is.na(LotFrontage) == TRUE)
    #im2<-subset(imputedLFH, is.na(LotFrontage) == FALSE)
    #im3<-im1
    #im3$LotFrontageHat<-case_when(im3$LotFrontageHat >= 200 ~ 225,
    #                              TRUE ~im3$LotFrontageHat)
    #w1<-ggplot(data=im2,aes(x=LotFrontage, y=SalePrice))+
    #  geom_point()+
    #  geom_smooth()

    #w2<-ggplot(data=im1, aes(x=LotFrontageHat, y=SalePrice))+
    #  geom_point()+
    #  geom_smooth()

    #w3<-ggplot(data=im3, aes(x=LotFrontageHat, y=SalePrice))+
    #  geom_point()+
    #  geom_smooth()

    #plot_grid(w1,w2, w3)
    ###############################END################################


    #create_report(data_f)
    plot_intro(data_f)
    plot_missing(data_f)
    ```

```{r Rondtossery}


####DELETE HERE
data_fg<-data_f

data_f_t<-subset(data_f, Type=="train_set")  

f1<-ggplot(data=data_f, aes(x=LotFrontage, y=SalePrice))+
  geom_point(aes(col = LotConfig))+
  geom_smooth()

 
#NO MISSING FILLED
f2<-ggplot(data=data_ltz, aes(x=LotFrontage, y=SalePrice))+
  geom_point(aes(col = LotConfig))+
  geom_smooth()
  
f3<-ggplot(data=data_ltz, aes(x=LotFrontage, y=LotArea))+
  geom_point(aes(col = LotConfig))+
  geom_smooth()

plot_grid(f1,f2, f3)

summary(lm(LotFrontage~LotArea+LotConfig, data = data_ltz))
format( pR2(lm(LotFrontage~LotArea+LotConfig, data = data_ltz)), scientific = FALSE)
summary(lm(log(LotFrontage)~LotArea+LotConfig, data = data_ltz))

m3<-(glm(LotFrontage~LotArea+LotConfig, Gamma(link="log"), data = data_ltz))
with(summary(m3), 1 - deviance/null.deviance)

format( pR2(m3), scientific = FALSE)

ggplot(data_ltz, aes(x=(LotFrontage)))+
  geom_density(aes(x=(LotFrontage), y=..density..))



glm.t1<-glm(SalePrice~LotFrontage,
            family=Gamma(link = "log"),
            data  =data_f_t )
glm.t2<-glm(SalePrice~LotConfig,
            family=Gamma(link = "log"),
            data  =data_f_t )

bsh<-ggplot(data=data_ltz, aes(x=LotShape, y=SalePrice))+
  geom_boxplot()

ggplot(data=data_ltz, aes(x=LotShape))+
  geom_bar()

with(summary(glm.t1), 1 - deviance/null.deviance)
with(summary(glm.t2), 1 - deviance/null.deviance)
format( pR2(glm.t1), scientific = FALSE)

#subset(data_fg,SaleType=="Other")
b<-ggplot(data=data_f, aes(x=Utilities, y=SalePrice))+
  geom_boxplot()

bb<-ggplot(data=data_f, aes(x=Utilities, y=SalePrice))+
  geom_boxplot()

g<-ggplot(data=data_f, aes(x=Utilities) )+
  geom_bar() 

gg<-ggplot(data=data_fg, aes(x=HouseStyle) )+
  geom_bar() 

plot_grid(g, b, ncol = 2, nrow = 1)

plot_grid(gg, bb, ncol = 2, nrow = 1)

ggplot(data=data_fg, aes(x=MSSubClass, fill = HouseStyle, y = 1 ) )+
  geom_bar(position="fill", stat="identity") 
levels(as.factor(data_fg$HouseStyle))


g1 <- ggplot(data=data_fg, aes(x=Stories) )+
  geom_bar() 

g2 <-ggplot(data=data_fg, aes(x=Stories, y=SalePrice))+
  geom_boxplot()

plot_grid(g1, g2, ncol = 2, nrow = 1)

```

```{r REGROUPING}
##Regroup poorly represented factor levels
data_fg<-data_f[,81:82]
#Resulting factor changes
data_fg$Era<-case_when(data_f$MSSubClass == 20 ~ 'Newer',
                   data_f$MSSubClass == 60 ~ 'Newer',
                   data_f$MSSubClass == 120 ~ 'Newer',  
                   data_f$MSSubClass == 160 ~ 'Newer',
                     data_f$MSSubClass == 30 ~ 'Older',
                     data_f$MSSubClass == 70 ~ 'Older',
                   TRUE ~ 'NoAgeDifferentiation'  )

data_fg$MSZoning<-as.factor(case_when(data_f$MSZoning ==  "C (all)"  ~ "C (all)",
                            data_f$MSZoning =="FV" ~ "FV",
                            data_f$MSZoning == "RL" ~ "RL/RP",
                            data_f$MSZoning == "RP" ~ "RL/RP",
                            TRUE ~'Other'))
data_fg$MSZoning <-fct_reorder(data_fg$MSZoning, data_fg$SalePrice)

data_fg$Stories<-as.factor(case_when(data_f$HouseStyle == "1Story" ~ "1.0",
                          data_f$HouseStyle == "1.5Fin" ~ "1.5", 
                          data_f$HouseStyle =="1.5Unf" ~ "1.5",
                          data_f$HouseStyle == "2Story" ~ "2.0",          
                          data_f$HouseStyle == "2.5Fin" ~ "2.5",
                          data_f$HouseStyle == "2.5Unf" ~ "2.5",  
                          TRUE ~ 'Other'  ))

data_fg$SaleType<-as.factor(case_when(data_f$SaleType == 'COD' ~ 'COD',
          data_f$SaleType == 'Con' ~ 'GCon', #Contract grouped
          data_f$SaleType == 'ConLw' ~ 'GCon',
          data_f$SaleType == 'ConLI' ~ 'GCon',
          data_f$SaleType == 'ConLD' ~ 'GCon',
          data_f$SaleType == 'New' ~ 'New',
          data_f$SaleType == 'WD' ~ 'GWD',
          data_f$SaleType == 'CWD' ~ 'GWD',
          data_f$SaleType == 'VWD' ~ 'GWD',
          TRUE ~'Other'
          ))
data_fg$SaleType<-(fct_reorder(data_fg$SaleType, data_fg$SalePrice))

#DROP THE FOLLOWING DATA COLUMNS FOR POOR EXPOSURE/VARIANCE
#Utilities

plot_correlation(data_fg)
```

remaining missing rows for the training data set can't be explained. Let's drop these rows from the training set to run our first few models. The new plots show we have a complete data set

```{r FillingInMissing}
subset(mcd, is.na(MSZoning) == TRUE )

#training set
data_f_t<-subset(data_f, Type=="train_set")            
data_f_t<-subset(data_f_t, is.na(MasVnrType) == FALSE )
data_f_t<-subset(data_f_t, is.na(Electrical) == FALSE )

plot_intro(data_f_t)
plot_missing(data_f_t)  
#create_report(data_f_t)


```

The correlation heatmap from the ExploratoryData package's report is too dense to read properly. For a parameterised model multicollinearity is not good at all.

```{r MULTICOLLINEARITY}
factorNames <- c('MSSubClass', 'MSZoning')
data_f <- data_f %>%
  mutate(across(factorNames, as.factor))

str(data_f)

data_f<-
mcd<-data_f[,c(2:3,81)]
plot_correlation(mcd)
plot_correlation(mcd$MSZoning)

b1<-ggplot(data=mcd, aes(x=MSSubClass, y=SalePrice))+
  geom_boxplot()

b2<-ggplot(data=mcd, aes(x=MSZoning, y=SalePrice))+
  geom_boxplot()

g1<-ggplot(data=mcd, aes(x=MSSubClass) )+
  geom_bar() 

g2<-ggplot(data=mcd, aes(x=MSZoning) )+
  geom_bar() 

plot_grid(b1, g1, ncol = 2, nrow = 1)
plot_grid(b2, g2, ncol = 2, nrow = 1)

subset(mcd, is.na(MSZoning) == TRUE )
```

```{r DependentDistributionExploration}

ggplot(data_f_t, aes(x=SalePrice))+
  geom_density(aes(x=SalePrice, y=..density..))

data_f_t$logPrice<-log(data_f_t$SalePrice)

ggplot(data_f_t)+
  geom_density(aes(x=logPrice, y=..density..))


```

The natural log transform does seem to make the dependent variable more symmetrical. Lets explore the three GLMs (Gamma:log, Gamma:inv, gamma:id) with a forward stepwise variable selection to decide which GLM is best

In terms of the model selevction we need a good balance between Mcfadden's pseudo R-square, Nagelkerke's R-square and plain R-square. As expected the McF's R2 is severely penalised due to too many parameters.

```{r}
library(stats)
library(caTools)

str(data_f_t)
#We need to remove the variables we do not want to use in the model;
data_f_t<-data_f_t[,2:81]
set.seed(101) 
sample = sample.split(data_f_t$SalePrice, SplitRatio = .85)
T_Train = subset(data_f_t, sample == TRUE)
T_Val  = subset(data_f_t, sample == FALSE)


glm.M1<-glm(SalePrice~.,
            family=Gamma(link = "log"),
            data    = T_Train)

with(summary(glm.M1), 1 - deviance/null.deviance)
format( pR2(glm.M1), scientific = FALSE)
#summary(glm.M1)

step_gamma_glm<-step(glm.M1)
step_gamma_glm$aic
step_gamma_glm$anova
step_gamma_glm$finalModel

x<-step_gamma_glm$model
yhat<-step_gamma_glm$fitted.values
y<-T_Train$SalePrice
fitted<-as.data.frame(cbind(yhat,y))

finalModel<-glm(formula = SalePrice ~ MSZoning + LotArea + Street + LandContour + 
    Utilities + LotConfig + LandSlope + Neighborhood + Condition1 + 
    Condition2 + BldgType + OverallQual + OverallCond + YearBuilt + 
    YearRemodAdd + RoofMatl + Exterior1st + MasVnrArea + ExterCond + 
    Foundation + BsmtExposure + BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF + 
    Heating + HeatingQC + CentralAir + X1stFlrSF + X2ndFlrSF + 
    LowQualFinSF + BsmtFullBath + FullBath + HalfBath + KitchenAbvGr + 
    KitchenQual + TotRmsAbvGrd + Functional + Fireplaces + GarageYrBlt + 
    GarageCars + GarageArea + GarageQual + GarageCond + WoodDeckSF + 
    EnclosedPorch + X3SsnPorch + ScreenPorch + PoolArea + PoolQC + 
    Fence + SaleType + SaleCondition, family = Gamma(link = "log"), 
    data = T_Train)
summary(finalModel)



valResult<-predict(finalModel,T_Val)

ggplot(fitted, aes(x=yhat, y=y))+
  geom_jitter()+
  geom_line(aes(x=y, y=y))

mse
```

After that we will do some feature engineering to see if there is an improvement

These are unused codes

```{r}
library(sqldf)
sqldf("Select * from data_f where MasVnrType is null")

c<-sqldf("Select MSZoning, MSSubClass, count(*) from missing
group by MSZoning,MSSubClass
      ")

FV<-sqldf("Select MSZoning, Street, count(*) total, sum(case when LotFrontage is null then 1 else 0 end) count_missing
          from data_f
          group by 1,2")

FV<-sqldf("Select *, sum(count_missing)/sum(total) from FV")
#create_report(data)


VIOLIN PLOT
vp1 <- ggplot(mcd, aes(x=MSSubClass, y=SalePrice)) +
  geom_violin()+
  geom_boxplot(width=0.1)
```

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
